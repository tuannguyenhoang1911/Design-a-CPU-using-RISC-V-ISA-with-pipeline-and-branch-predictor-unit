//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module RISCV_v1(

	//////////// CLOCK //////////
	input 		          		  CLOCK_50,
	input                        reset,
	//////////// INPUT //////////
	input 		       [9:0]	  SW,

	//////////// OUTPUT //////////
	output		       [9:0]	  LEDR,
	output          a,
	output [1:0] b,
	output 		       [31:0]    r,r1,r2
);

//=======================================================
//  REG/WIRE declarations
//=======================================================
wire [6:0]  w_opcode	   ;  								            // out ID
wire [4:0]  w_rd, w_rd_reg, w_rd_reg1, w_rd_reg2;              // out ID
wire [4:0]  w_rs1	 	   ;   								            // out ID
wire [4:0]  w_rs2	 	   ;   												// out ID
wire [4:0]  w_rs1_reg, w_rs2_reg, w_rs2_reg1;					   // out Reg_ID_EX
wire [2:0]  w_funct3	   ;   												// out ID
wire [6:0]  w_funct7	   ;   												// out ID
wire [2:0]  w_type	   ;   												// out ID, in ImmGen
wire [31:0] w_imm, w_imm_reg;   											// out ImmGen
wire [31:0] w_addr_ins, w_addr_ins_temp  ;   						// out PC, in Reg_IF_ID
wire [31:0] w_addr_ins_reg, w_addr_ins_reg1,w_addr_ins_reg2;   // out Reg_IF_ID -> Reg_ID_EX -> CLA1
wire [31:0] w_addr_ins1 ;   												// input of A of adder 1 to calculate nextPC (currentPC or rs1)
wire [31:0] w_ins       ;   												// out IM, in ID, in Reg_IF_ID
wire [31:0] w_ins_reg   ;   												// out Reg_IF_ID -> in ID
wire [31:0] w_readdata1, w_readdata2; 									// w_readdata1: out RegFile -> Reg_ID_EX -> in ALU
wire [31:0] w_readdata1_reg, w_readdata2_reg, w_readdata2_reg1;// w_readdata2: out RegFile -> Reg_ID_EX -> in ALU -> Reg_EX_MEM
wire [31:0] w_readdata1_forward, w_readdata2_forward;
wire [31:0] w_inALU2    ;   												// in ALU2
wire [31:0] w_inALU1    ;   												// in ALU1
wire        w_Branch, w_MemRd, w_MemWr; 								// out Control unit -> Reg_ID_EX -> Reg_EX_MEM
wire        w_Branch_reg, w_MemRd_reg, w_MemWr_reg;				// out Reg_ID_EX
wire        w_Branch_reg1, w_MemRd_reg1, w_MemWr_reg1; 			// out Reg_EX_MEM
wire        w_MemRd_reg2;
wire        w_MemRd_reg3, w_RegWr_reg3;								// out Reg_AfterMEM_WB
wire [4:0]  w_rd_reg3;             										// out Reg_AfterMEM_WB
wire        w_MemtoReg, w_MemtoReg_reg, w_MemtoReg_reg1, w_MemtoReg_reg2; // out Control unit -> Reg_ID_EX -> Reg_EX_MEM -> Reg_MEM_WB
wire        w_RegWr, w_RegWr_reg, w_RegWr_reg1, w_RegWr_reg2; 	// out Control unit -> Reg_ID_EX -> Reg_EX_MEM -> Reg_MEM_WB
wire [3:0]  w_ALUOp,w_ALUOp_reg;  									   // out Control unit
wire [31:0] w_ALUresult, w_ALUresult_reg, w_ALUresult_reg1;    // out ALU -> Reg_EX_MEM -> in DataMem or Reg_MEM_WB
wire [31:0] w_ReadData, w_ReadData_reg  ;   							// out DataMem -> Reg_MEM_WB -> RegFile
wire [31:0] w_WriteData ;  												// in RegFile,
wire [31:0] w_WriteData1;   												// out Mux after DataMem,
wire [31:0] w_MemDataWr, w_MemDataWr1;									// in DataMem
wire        w_zero, w_zero_reg;   										// out ALU,
wire        w_lt, w_lt_reg;  											   // out ALU,
wire [1:0]  w_BrOp,w_BrOp_reg, w_BrOp_reg1;   						// out Control unit
wire [31:0] w_Normal_ins;   												// out Adder1, PC + 4
wire [31:0] w_Branch_ins, w_Branch_ins_reg;   						// out Adder2,
wire [31:0] w_Next_ins  ;   												// out mux top, in PC
wire        w_Next_ins_temp, w_Next_ins_temp1;
wire        w_ALUOF, w_ALUneg, w_adder1OF, w_adder1zero, w_adder2OF, w_adder2zero; // non-connect
wire        w_Jump, w_PCspecial,w_Jump_reg, w_PCspecial_reg, w_Jump_reg1, w_PCspecial_reg1;
wire [1:0]  w_Asel, w_ALUSrc; 											// select inputs of 1st and 2nd ALU operand
wire [1:0]  w_Asel_reg, w_ALUSrc_reg; 									// out Reg_ID_EX
wire [2:0]  w_Load_sel, w_Load_sel_reg, w_Load_sel_reg1, w_Load_sel_reg2; // out Control Unit -> Reg_ID_EX -> Reg_EX_MEM -> Reg_MEM_WB
wire [1:0]  w_Store_sel, w_Store_sel_reg, w_Store_sel_reg1; 	// out Control Unit -> Reg_ID_EX -> Reg_EX_MEM
wire [1:0]  w_ForwardASel, w_ForwardBSel;                      // output of Forwarding unit
wire        w_ForwardStoSel;                                    // output of Forwarding unit_MEM
wire [31:0] w_WriteData_hazard;
wire        w_PC_remain, w_Reg_IF_ID_remain, w_zero_control;   // output of Hazard_Detection_Unit
wire [31:0] w_target_predict;
wire [31:0] actual_pc_temp, actual_pc;
wire        w_pc_sel,w_predict_bit_BP,w_predict_bit_BP_reg,w_predict_bit_BP_reg1;
wire        w_wrong_predict;
//=======================================================
//  Structural coding
//=======================================================

Control_Unit (
    //.clk       (CLOCK_50)  ,
    //.rst_n ()    ,
	 .zero_control (w_zero_control | w_wrong_predict),
	 .type      (w_type)     ,
    .opcode    (w_opcode)   ,  
    .funct7    (w_funct7)   ,
    .funct3    (w_funct3)   ,
    .Branch    (w_Branch)   , // notify B-type instruction
	 .Jump      (w_Jump)     , // notify J-type instruction and Jump
	 .PCspecial (w_PCspecial), // only 1 when jalr (nextPC depends on rs1); otherwise NextPC depends on currentPC)
    .MemtoReg  (w_MemtoReg) , // connect to mux after DataMem
    .ALUSrc    (w_ALUSrc)   , // connect to mux select input ALU2
	 .Asel      (w_Asel)     , // select input of 1st operand of ALU
    .MemRd     (w_MemRd)    , // connect to DataMem  
	 .MemWr     (w_MemWr)    , // connect to DataMem
    .RegWr     (w_RegWr)    , // connect to registers file
	 .BrOp      (w_BrOp)     ,
	 .Load_sel  (w_Load_sel) ,
	 .Store_sel (w_Store_sel),
    .ALUOp     (w_ALUOp)      // connect to ALU
);

Hazard_Detection_Unit (
    .id_rs1           (w_ins[19:15])      , // From IM  
    .id_rs2           (w_ins[24:20])      , // From IM
	 .id_rd            (w_ins[11:7])       , // From IM 
    .ex_rd            (w_rd_reg)          , // From Reg_ID_EX 
    .ex_MemRd         (w_MemRd_reg)       , // From Reg_ID_EX 
    .PC_remain        (w_PC_remain)       , // -> PC
	 .Reg_IF_ID_remain (w_Reg_IF_ID_remain), // -> Reg_IF_ID
	 .zero_control     (w_zero_control)      // -> Control Unit    
);

Reg_IF_ID (
    .clk   (CLOCK_50)      ,
	 .rst   (reset | w_wrong_predict) ,
	 .Reg_IF_ID_remain (w_Reg_IF_ID_remain),
	 .if_predicted_bit (w_predict_bit_BP),
    .if_pc (w_addr_ins)    ,
    .if_inst (w_ins)       ,
	 .id_pc (w_addr_ins_reg),
	 .id_predicted_bit (w_predict_bit_BP_reg),
    .id_inst (w_ins_reg)
);


Reg_ID_EX (
  //Input 
    .clk          (CLOCK_50),
	 .rst          (reset | w_wrong_predict),
    .id_pc        (w_addr_ins_reg), // output of reg IF/ID
    .id_DataA     (w_readdata1)   , // output of Register File: readdata1
    .id_DataB     (w_readdata2)   , // output of Register File: readdata2
    .id_rd        (w_rd)       ,    // output of Instruction Decode
    .id_rs1       (w_rs1),          // output of Instruction Decode
    .id_rs2       (w_rs2),          // output of Instruction Decode
    .id_Branch    (w_Branch)   ,    // output of Control Unit to notify B-type instruction
    .id_Jump      (w_Jump)     ,    // output of Control Unit to notify J-type instruction
    .id_PCspecial (w_PCspecial),    // output of Control Unit to notify jalr instruction
    .id_ALUSrc    (w_ALUSrc)   ,    // output of Control Unit to select 2nd operand of ALU
    .id_Asel      (w_Asel)     ,    // output of Control Unit to select 1st operand of ALU
    .id_MemRd     (w_MemRd)    ,    // output of Control Unit to read from DataMem
    .id_MemWr     (w_MemWr)    ,  	// output of Control Unit to write to DataMem
    .id_RegWr     (w_RegWr)    ,    // output of Control Unit to write to Register File
    .id_MemtoReg  (w_MemtoReg) ,    // output of Control Unit to control Mux after DataMem
    .id_ALUOp     (w_ALUOp)    ,    // output of Control Unit to select ALU
    .id_BrOp      (w_BrOp)     ,    // output of Control Unit to select type of Branch
    .id_Load_sel  (w_Load_sel) ,    // output of Control Unit to select type of Load
    .id_Store_sel (w_Store_sel),    // output of Control Unit to select type of Store
    .id_imm       (w_imm)      ,    // output of ImmGen
	 .id_predicted_bit (w_predict_bit_BP_reg),
	 //.ex_inst		(w_ins_reg1)           ,
    .ex_pc 		   (w_addr_ins_reg1),
    .ex_DataA     (w_readdata1_reg),
    .ex_DataB     (w_readdata2_reg),
    .ex_rd        (w_rd_reg)       ,
	 .ex_rs1       (w_rs1_reg)      ,// -> Forwarding unit
    .ex_rs2       (w_rs2_reg)      ,// -> Forwarding unit
    .ex_Branch    (w_Branch_reg)   ,// -> Reg EX_MEM
    .ex_Jump      (w_Jump_reg)     ,// -> Reg EX_MEM
    .ex_PCspecial (w_PCspecial_reg),// -> Reg EX_MEM
    .ex_ALUSrc    (w_ALUSrc_reg)   ,
    .ex_Asel      (w_Asel_reg)     ,
    .ex_MemRd     (w_MemRd_reg)    ,
    .ex_MemWr     (w_MemWr_reg)    ,
    .ex_RegWr     (w_RegWr_reg)    ,// -> Reg EX_MEM -> RegMEM_WB -> RegFile
    .ex_MemtoReg  (w_MemtoReg_reg) ,// -> Reg EX_MEM -> RegMEM_WB -> mux after DataMem
    .ex_ALUOp     (w_ALUOp_reg)    ,// -> ALU
    .ex_BrOp      (w_BrOp_reg)     ,// -> Reg EX_MEM
    .ex_Load_sel  (w_Load_sel_reg) ,// Reg EX_MEM -> RegMEM_WB -> mux after  mux of DataMem
    .ex_Store_sel (w_Store_sel_reg),// -> Reg EX_MEM -> mux -> WriteData of DataMem
    .ex_imm       (w_imm_reg),			// CLA1
	 .ex_predicted_bit (w_predict_bit_BP_reg1)
);

Forwarding_Unit (
    .ex_rs1     (w_rs1_reg),     // from Reg_ID_EX
    .ex_rs2     (w_rs2_reg),     // from Reg_ID_EX
    .mem_rd     (w_rd_reg1),     // from Reg_EX_MEM
    .wb_rd      (w_rd_reg2),     // from Reg_MEM_WB
    .mem_RegWr  (w_RegWr_reg1),  // from Reg_EX_MEM
    .wb_RegWr   (w_RegWr_reg2),  // from Reg_MEM_WB
    .mem_MemRd  (w_MemRd_reg1),  // from Reg_EX_MEM
	 .wb_MemRd   (w_MemRd_reg2),
	 .extra_MemRd (w_MemRd_reg3),
	 .extra_rd   (w_rd_reg3),     // from Reg_After_MEM_WB
	 .extra_RegWr (w_RegWr_reg3), // from Reg_After_MEM_WB
	 .mem_MemWr  (w_MemWr_reg1),  // from Reg_EX_MEM
    .ForwardASel(w_ForwardASel),
    .ForwardBSel(w_ForwardBSel) 
  );
  

Reg_EX_MEM (
  //Input from EX
    .clk           (CLOCK_50),
    .rst           (reset | w_wrong_predict),
    .ex_MemRd      (w_MemRd_reg), 	 // Control Unit -> Reg_EX_MEM
    .ex_RegWr      (w_RegWr_reg), 	 // Control Unit -> Reg_EX_MEM
    .ex_MemWr      (w_MemWr_reg), 	 // Control Unit -> Reg_EX_MEM
    .ex_MemtoReg   (w_MemtoReg_reg), // Control Unit -> Reg_EX_MEM
    .ex_zero       (w_zero),         // ALU -> Reg_EX_MEM
    .ex_lt         (w_lt),			    // ALU -> Reg_EX_MEM
    .ex_rd         (w_rd_reg), 		 // ID block     -> Reg_EX_MEM
	 .ex_rs2        (w_rs2_reg),      // Reg ID_EX    -> Reg_EX_MEM
    .ex_pc         (w_Branch_ins),   // result of 1st CLA
	 .ex_pc_ori     (w_addr_ins_reg1), // current PC
    .ex_readdata2  (w_readdata2_reg),// Reg file     -> Reg ID_EX  -> Reg_EX_MEM
    .ex_BrOp       (w_BrOp_reg),     // Control Unit -> Reg ID_EX  -> Reg_EX_MEM
    .ex_Branch     (w_Branch_reg),   // Control Unit -> Reg ID_EX  -> Reg_EX_MEM
    .ex_Jump       (w_Jump_reg),     // Control Unit -> Reg ID_EX  -> Reg_EX_MEM
    //.ex_PCspecial  (w_PCspecial_reg),// Control Unit -> Reg ID_EX  -> Reg_EX_MEM
    .ex_Load_sel   (w_Load_sel_reg), // Control Unit -> Reg ID_EX  -> Reg_EX_MEM -> Reg Mem/WB
    .ex_Store_sel  (w_Store_sel_reg), // Control Unit -> Reg ID_EX  -> Reg_EX_MEM -> DataMem
    .ex_ALU_result (w_ALUresult),
	 .ex_predicted_bit (),
  //Output to MEM                
    .mem_MemRd     (w_MemRd_reg1), 	 	 // -> DataMem
    .mem_RegWr     (w_RegWr_reg1),   	 // -> Reg MEM_WB
    .mem_MemWr     (w_MemWr_reg1),  	 // -> DataMem
    .mem_MemtoReg  (w_MemtoReg_reg1),	 // -> Reg MEM_WB
    .mem_zero      (w_zero_reg),     	 // B-type sel
    .mem_lt        (w_lt_reg),       	 // B-type sel      ,
    .mem_rd        (w_rd_reg1),      	 // -> Reg MEM_WB
	 .mem_rs2       (w_rs2_reg1),
    .mem_pc		    (w_Branch_ins_reg),  // -> Mux before PC 
	 .mem_pc_ori    (w_addr_ins_reg2),
    .mem_readdata2 (w_readdata2_reg1),  // -> input of Load Mux
    .mem_BrOp      (w_BrOp_reg1),       // B-type sel
    .mem_Branch    (w_Branch_reg1),     // B-type sel
    .mem_Jump      (w_Jump_reg1),       // B-type sel
    //.mem_PCspecial (w_PCspecial_reg1),// B-type sel
    .mem_Load_sel  (w_Load_sel_reg1),   // ->  Load Mux
    .mem_Store_sel (w_Store_sel_reg1),  // -> Store Mux
    .mem_ALU_result (w_ALUresult_reg),   // -> addr of DataMem or Reg MEM_WB  
    .mem_predicted_bit ()	 
);

Forwarding_Unit_MEM (
    .mem_rs2       (w_rs2_reg1), // from Reg_EX_MEM
    .wb_rd         (w_rd_reg2), // from Reg_MEM_WB
    .mem_MemRd     (w_MemRd_reg1), // from Reg_EX_MEM
	 .mem_MemWr     (w_MemWr_reg1), // from Reg_EX_MEM
    .ForwardStoreSel (w_ForwardStoSel),
);

Reg_MEM_WB(
	 .clk           (CLOCK_50),
	 .rst				 (reset),
	 .mem_MemtoReg  (w_MemtoReg_reg1),  // from the output of Reg EX/MEM to control Mux after DataMem
	 .mem_RegWr     (w_RegWr_reg1), 	   // from the output of Reg EX/MEM to write to Reg File
	 .mem_rd        (w_rd_reg1),  		// ID -> IF/ID reg -> ID/EX reg -> EX/MEM Reg -> MEM/WB Reg 
	 .mem_MemRd     (w_MemRd_reg1),
	 .datamem  	    (w_ReadData),  		// from the output of readdata of DataMem 
	 .dataALU		 (w_ALUresult_reg),  // ALU result -> EX/MEM Reg -> MEM/WB Reg
	 .mem_Load_sel  (w_Load_sel_reg1),  // ALU result -> EX/MEM Reg -> MEM/WB Reg
	 .wb_dataALU	 (w_ALUresult_reg1),
	 .wb_datamem	 (w_ReadData_reg),
	 .wb_memtoreg	 (w_MemtoReg_reg2),
	 .wb_RegWr  	 (w_RegWr_reg2),
	 .wb_MemRd      (w_MemRd_reg2),
	 .wb_Load_sel	 (w_Load_sel_reg2),
	 .wb_rd			 (w_rd_reg2)
);

Reg_After_MEM_WB (
   .clk            (CLOCK_50),
   .rst            (reset),
   .wb_MemRd       (w_MemRd_reg2),
	.wb_RegWr       (w_RegWr_reg2),
   .wb_rd          (w_rd_reg2),
   .extra_MemRd    (w_MemRd_reg3),// -> Forward Unit
	.extra_RegWr    (w_RegWr_reg3),
   .extra_rd       (w_rd_reg3),
);

ALU mainALU (
	 .in1        (w_inALU1),
	 .in2        (w_inALU2)   ,
	 .sel        (w_ALUOp_reg),
	 .ALU_result (w_ALUresult),
	 .ALU_of     (w_ALUOF)    ,
	 .ALU_zero   (w_zero)     ,
	 .ALU_lt     (w_lt),
	 .ALU_neg    (w_ALUneg)
);

module_32_D_FF PC (
    .i_clr      (0)          ,
    .PC_remain  (w_PC_remain), 
    .i_D        (w_Next_ins) ,
	 .i_clk      (CLOCK_50)   ,
	 .o_Q        (w_addr_ins)
);
//assign w_addr_ins = (w_pc_sel) ? w_target_predict : w_addr_ins_temp;

Instruction_Memory IM (
    .pc          (w_addr_ins),
    //.clk         (CLOCK_50)  ,
    .instruction (w_ins)     
);

Instruction_Decode ID (
  .instruction  (w_ins_reg), 
  .opcode       (w_opcode),
  .rd           (w_rd)    ,
  .rs1          (w_rs1)   ,
  .rs2          (w_rs2)   ,
  .funct3       (w_funct3),
  .funct7       (w_funct7),
  .type			 (w_type)
);

RegisterFile RegFile (
	.readreg1    (w_rs1)       ,
	.readreg2    (w_rs2)       ,
	.writereg    (w_rd_reg2)   ,
	.writedata   (w_WriteData) ,
	.write       (w_RegWr_reg2),
	.clk         (CLOCK_50)    ,
	.rst         (reset)       ,
	.readdata1   (w_readdata1) ,
	.readdata2	 (w_readdata2)
);

//assign r = w_Next_ins;
//assign r2 = w_target_predict;
//assign a = w_predict_bit_BP_reg1;
/*assign LEDR[8] = w_wrong_predict;
assign LEDR[7] = w_Next_ins_temp1;
assign LEDR[6] = w_pc_sel;*/

Branch_Predictor_Unit
(    
    .clk              (CLOCK_50),
	 .rst              (reset),
	 .i_update         (w_Branch_reg | w_Jump_reg),     // inform B,J type
	 .i_taken          (w_Next_ins_temp1),
	 .i_pc_ex          (w_addr_ins_reg1), // after Reg ID_EX
	 .i_pc_in          (w_addr_ins),
	 .i_target_pc      (w_Branch_ins),	 
	 .o_pc_sel         (w_pc_sel),       // PC + 4 or BJ
	 //.temp   (LEDR[1:0]),
	 //output  pc_fix,
	 .o_target_predict (w_target_predict),
	 //.w_LPT_index (a),
	 //.w_LPT_index_update (b),
	 //.o_LBP_predict_temp (b),
	 .o_predict_bit_BP (w_predict_bit_BP)
);

assign w_wrong_predict = ((w_Next_ins_temp1 ^ w_predict_bit_BP_reg1) & (w_Branch_reg | w_Jump_reg));
  
assign w_addr_ins1 = (w_PCspecial_reg) ? w_readdata1_reg : w_addr_ins_reg1; 
CLA Adder1 (
    .i_A        (w_addr_ins1) ,
	 .i_B        (w_imm_reg)   ,
	 .i_mode     (0)           ,   //0: add; 1: sub
	 .S          (w_Branch_ins),
	 .overflow   (w_adder1OF)  ,
	 .zero       (w_adder1zero)
);
CLA Adder2 (
    .i_A        (w_addr_ins)  ,
	 .i_B        (3'b100)      ,
	 .i_mode     (0)           ,   //0: add; 1: sub
	 .S          (w_Normal_ins),
	 .overflow   (w_adder2OF)  ,
	 .zero       (w_adder2zero)
);
assign w_Next_ins_temp = (w_BrOp_reg[1]) ? (w_BrOp_reg[0] ? (~w_lt_reg) & w_Branch_reg : w_lt_reg & w_Branch_reg) : (w_BrOp_reg1[0] ? ~(w_zero_reg) & w_Branch_reg1 : w_zero_reg & w_Branch_reg1);// mux PC selection
assign w_Next_ins_temp1 = w_Next_ins_temp | w_Jump_reg;
//assign w_Next_ins = (w_Next_ins_temp1) ? w_Branch_ins_reg : w_Normal_ins;
assign w_Next_ins = (w_wrong_predict) ? actual_pc : (w_pc_sel) ? w_target_predict : w_Normal_ins;

assign actual_pc = (w_Next_ins_temp | w_Jump_reg) ? w_Branch_ins: w_Normal_ins;
  

Data_Memory DataMem (
    .clk        (CLOCK_50)        ,
    .Address    (w_ALUresult_reg) ,
    .DataWrite  (w_MemDataWr)     ,
    .MemWr      (w_MemWr_reg1)    ,
    .MemRd      (w_MemRd_reg1)    ,
    .ReadData   (w_ReadData)        
);
assign w_WriteData1 = (w_MemtoReg_reg2) ? w_ReadData_reg : w_ALUresult_reg1; // mux after DataMem
assign w_WriteData = (w_Load_sel_reg2[2]) ? w_WriteData1 : (w_Load_sel_reg2[1]) ? (w_Load_sel_reg2[0]) ? {16'b0,w_WriteData1[15:0]} : {24'b0,w_WriteData1[7:0]} : (w_Load_sel_reg2[0]) ? {{16{w_WriteData1[15]}},w_WriteData1[15:0]}: {{24{w_WriteData1[7]}},w_WriteData1[7:0]};

assign w_MemDataWr1 = (w_Store_sel_reg1[1]) ? w_readdata2_reg1 : (w_Store_sel_reg1[0]) ? {{16{w_readdata2_reg1[15]}},w_readdata2_reg1[15:0]} : {{24{w_readdata2_reg1[7]}},w_readdata2_reg1[7:0]};

assign w_MemDataWr = (w_ForwardStoSel)? w_WriteData_hazard : w_MemDataWr1;
assign w_WriteData_hazard = (w_Store_sel_reg1[1]) ? w_WriteData1 : (w_Store_sel_reg1[0]) ? {{16{w_WriteData1[15]}},w_WriteData1[15:0]} : {{24{w_WriteData1[7]}},w_WriteData1[7:0]};

assign r1 = w_WriteData;

Imm_Gen ImmGen (
    .inst 		  (w_ins_reg), 
    .type     	  (w_type) ,	
    .imm         (w_imm)  ,
);

assign w_inALU1 = (w_Asel_reg[1])? 3'b000 : (w_Asel_reg[0])? w_addr_ins_reg1 : w_readdata1_forward ; // mux before ALU1; 00:rs1, 01:PC, 10: 0
assign w_inALU2 = (w_ALUSrc_reg[1])? 3'b100 : (w_ALUSrc_reg[0])? w_imm_reg : w_readdata2_forward ; // mux before ALU2; 00:rs2, 01:imm, 10: 4

assign w_readdata1_forward = (w_ForwardASel[1])? w_ALUresult_reg : (w_ForwardASel[0])? w_WriteData : w_readdata1_reg;
assign w_readdata2_forward = (w_ForwardBSel[1])? w_ALUresult_reg : (w_ForwardBSel[0])? w_WriteData : w_readdata2_reg;

endmodule 







